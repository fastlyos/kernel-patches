From:	Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
To:	linux-btrfs@vger.kernel.org
Cc:	dsterba@suse.cz
Subject: [PATCH 1/2] btrfs: use correct offset for reloc_inode in prealloc_file_extent_cluster()
Date:	Wed,  6 Jul 2016 18:37:52 +0800

In prealloc_file_extent_cluster(), btrfs_check_data_free_space() uses
wrong file offset for reloc_inode, it uses cluster->start and cluster->end,
which indeed are extent's bytenr. The correct value should be
cluster->[start|end] minus block group's start bytenr.

start bytenr   cluster->start
|              |     extent      |   extent   | ...| extent |
|----------------------------------------------------------------|
|                block group reloc_inode                         |

[HH: backported to 4.4++]
Signed-off-by: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
---
 fs/btrfs/relocation.c | 27 +++++++++++++++------------
 1 file changed, 15 insertions(+), 12 deletions(-)

diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 0477dca..abc2f69 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -3030,34 +3030,37 @@ int prealloc_file_extent_cluster(struct inode *inode,
 	u64 num_bytes;
 	int nr = 0;
 	int ret = 0;
+	u64 prealloc_start, prealloc_end;
 
 	BUG_ON(cluster->start != cluster->boundary[0]);
 	mutex_lock(&inode->i_mutex);
 
-	ret = btrfs_check_data_free_space(inode, cluster->start,
-					  cluster->end + 1 - cluster->start);
+	start = cluster->start - offset;
+	end = cluster->end - offset;
+	ret = btrfs_check_data_free_space(inode, start, end + 1 - start);
 	if (ret)
 		goto out;
 
 	while (nr < cluster->nr) {
-		start = cluster->boundary[nr] - offset;
+		prealloc_start = cluster->boundary[nr] - offset;
 		if (nr + 1 < cluster->nr)
-			end = cluster->boundary[nr + 1] - 1 - offset;
+			prealloc_end = cluster->boundary[nr + 1] - 1 - offset;
 		else
-			end = cluster->end - offset;
+			prealloc_end = cluster->end - offset;
 
-		lock_extent(&BTRFS_I(inode)->io_tree, start, end);
-		num_bytes = end + 1 - start;
-		ret = btrfs_prealloc_file_range(inode, 0, start,
+		lock_extent(&BTRFS_I(inode)->io_tree, prealloc_start,
+			    prealloc_end);
+		num_bytes = prealloc_end + 1 - prealloc_start;
+		ret = btrfs_prealloc_file_range(inode, 0, prealloc_start,
 						num_bytes, num_bytes,
-						end + 1, &alloc_hint);
-		unlock_extent(&BTRFS_I(inode)->io_tree, start, end);
+						prealloc_end + 1, &alloc_hint);
+		unlock_extent(&BTRFS_I(inode)->io_tree, prealloc_start,
+			      prealloc_end);
 		if (ret)
 			break;
 		nr++;
 	}
-	btrfs_free_reserved_data_space(inode, cluster->start,
-				       cluster->end + 1 - cluster->start);
+	btrfs_free_reserved_data_space(inode, start, end + 1 - start);
 out:
 	mutex_unlock(&inode->i_mutex);
 	return ret;
