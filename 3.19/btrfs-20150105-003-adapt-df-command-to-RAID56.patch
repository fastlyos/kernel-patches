From: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
Newsgroups: gmane.comp.file-systems.btrfs
Subject: [PATCH v2 3/3] Btrfs: adapt df command to RAID5/6.
Date: Mon, 5 Jan 2015 18:07:05 +0800
Archived-At: <http://permalink.gmane.org/gmane.comp.file-systems.btrfs/42004>

When we use btrfs with raid5/6, the output of df is unexpected as below.
Example:
        # mkfs.btrfs -f /dev/vdf1 /dev/vdf2 -d raid5
        # mount /dev/vdf1 /mnt
        # dd if=/dev/zero of=/mnt/zero bs=1M count=1000
        # df -h /mnt
Filesystem      Size  Used Avail Use% Mounted on
/dev/vdf1       4.2G  1.3G  2.9G  32% /mnt
[root@atest-guest linux_btrfs]# btrfs fi show /mnt
Label: none  uuid: f7fac7f2-3898-482e-9cf2-fbcd7fdd7084
	Total devices 2 FS bytes used 1001.53MiB
	devid    1 size 2.00GiB used 1.85GiB path /dev/vdf1
	devid    2 size 4.00GiB used 1.83GiB path /dev/vdf2
The @size should be 2G rather than 4.2G.

This patch makes the btrfs_calc_avail_data_space() consider raid5/6,
then we can get the correct result of it.

Example:
        # mkfs.btrfs -f /dev/vdf1 /dev/vdf2 -d raid5
        # mount /dev/vdf1 /mnt
        # dd if=/dev/zero of=/mnt/zero bs=1M count=1000
        # df -h /mnt
Filesystem      Size  Used Avail Use% Mounted on
/dev/vdf1       2.0G  1.3G  713M  66% /mnt
[root@atest-guest linux_btrfs]# btrfs fi show /mnt
Label: none  uuid: ea3a6e6e-fbe1-47aa-b4b5-bc37b98565d9
	Total devices 2 FS bytes used 1001.53MiB
	devid    1 size 2.00GiB used 1.85GiB path /dev/vdf1
	devid    2 size 4.00GiB used 1.83GiB path /dev/vdf2

Signed-off-by: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
---
 fs/btrfs/super.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1f0f080..4a190de 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -52,6 +52,7 @@
 #include "props.h"
 #include "xattr.h"
 #include "volumes.h"
+#include "raid56.h"
 #include "export.h"
 #include "compression.h"
 #include "rcu-string.h"
@@ -1688,6 +1689,14 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		min_stripes = 4;
 		num_stripes = 4;
 		data_stripes = 2;
+	} else if (type & BTRFS_BLOCK_GROUP_RAID5) {
+		min_stripes = 2;
+		num_stripes = nr_devices;
+		data_stripes = num_stripes - nr_parity_stripes(type);
+	} else if (type & BTRFS_BLOCK_GROUP_RAID6) {
+		min_stripes = 3;
+		num_stripes = nr_devices;
+		data_stripes = num_stripes - nr_parity_stripes(type);
 	}
 
 	if (type & BTRFS_BLOCK_GROUP_DUP)
@@ -1777,8 +1786,11 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	while (nr_devices >= min_stripes) {
 		if (num_stripes > nr_devices) {
 			num_stripes = nr_devices;
-			if (type & BTRFS_BLOCK_GROUP_RAID0)
-				data_stripes = num_stripes;
+			/* Only RAID0, RAID5 and RAID6 will get here.
+			 * And we can use the following calculation
+			 * for all the three cases.
+			 **/
+			data_stripes = num_stripes - nr_parity_stripes(type);
 		}
 
 		if (devices_info[i].max_avail >= min_stripe_size) {
-- 
1.8.4.2
