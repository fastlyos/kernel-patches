From 4453641fe85f2ffda653e2e61b6a554dba1f0581 Mon Sep 17 00:00:00 2001
From: Al Viro <viro@zeniv.linux.org.uk>
Date: Fri, 26 Sep 2014 22:54:02 -0400
Subject: __d_materialise_dentry(): flip the order of arguments

... thus making it much closer to (now unreachable, BTW) IS_ROOT(dentry)
case in __d_move().  A bit more and it'll fold in.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/dcache.c b/fs/dcache.c
index 86afdf1..0551fcc 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -2635,38 +2635,34 @@ out_err:
  * Prepare an anonymous dentry for life in the superblock's dentry tree as a
  * named dentry in place of the dentry to be replaced.
  */
-static void __d_materialise_dentry(struct dentry *dentry, struct dentry *anon)
+static void __d_materialise_dentry(struct dentry *dentry, struct dentry *target)
 {
-	struct dentry *dparent;
-
-	dentry_lock_for_move(anon, dentry);
+	dentry_lock_for_move(dentry, target);
 
 	write_seqcount_begin(&dentry->d_seq);
-	write_seqcount_begin_nested(&anon->d_seq, DENTRY_D_LOCK_NESTED);
-
-	dparent = dentry->d_parent;
+	write_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);
 
-	switch_names(dentry, anon);
-	swap(dentry->d_name.hash, anon->d_name.hash);
+	switch_names(dentry, target);
+	swap(dentry->d_name.hash, target->d_name.hash);
 
-	dentry->d_parent = dentry;
-	list_del_init(&dentry->d_u.d_child);
-	anon->d_parent = dparent;
-	list_move(&anon->d_u.d_child, &dparent->d_subdirs);
-	if (likely(!d_unhashed(anon))) {
-		hlist_bl_lock(&anon->d_sb->s_anon);
-		__hlist_bl_del(&anon->d_hash);
-		anon->d_hash.pprev = NULL;
-		hlist_bl_unlock(&anon->d_sb->s_anon);
+	dentry->d_parent = target->d_parent;
+	target->d_parent = target;
+	list_del_init(&target->d_u.d_child);
+	list_move(&dentry->d_u.d_child, &dentry->d_parent->d_subdirs);
+	if (likely(!d_unhashed(dentry))) {
+		hlist_bl_lock(&dentry->d_sb->s_anon);
+		__hlist_bl_del(&dentry->d_hash);
+		dentry->d_hash.pprev = NULL;
+		hlist_bl_unlock(&dentry->d_sb->s_anon);
 	}
-	__d_rehash(anon, d_hash(anon->d_parent, anon->d_name.hash));
+	__d_rehash(dentry, d_hash(dentry->d_parent, dentry->d_name.hash));
 
+	write_seqcount_end(&target->d_seq);
 	write_seqcount_end(&dentry->d_seq);
-	write_seqcount_end(&anon->d_seq);
 
-	dentry_unlock_parents_for_move(anon, dentry);
+	dentry_unlock_parents_for_move(dentry, target);
+	spin_unlock(&target->d_lock);
 	spin_unlock(&dentry->d_lock);
-	spin_unlock(&anon->d_lock);
 }
 
 /**
@@ -2714,7 +2710,7 @@ struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)
 				return ERR_PTR(-EIO);
 			}
 			write_seqlock(&rename_lock);
-			__d_materialise_dentry(dentry, new);
+			__d_materialise_dentry(new, dentry);
 			write_sequnlock(&rename_lock);
 			spin_unlock(&inode->i_lock);
 			security_d_instantiate(new, inode);
@@ -2775,7 +2771,7 @@ struct dentry *d_materialise_unique(struct dentry *dentry, struct inode *inode)
 			} else if (IS_ROOT(alias)) {
 				/* Is this an anonymous mountpoint that we
 				 * could splice into our tree? */
-				__d_materialise_dentry(dentry, alias);
+				__d_materialise_dentry(alias, dentry);
 				write_sequnlock(&rename_lock);
 				goto found;
 			} else {
-- 
cgit v0.10.1

