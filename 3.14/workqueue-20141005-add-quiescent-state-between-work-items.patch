From: Joe Lawrence <joe.lawrence <at> stratus.com>
Subject: [PATCH v2 1/2] workqueue: add quiescent state between work items
Newsgroups: gmane.linux.kernel, gmane.linux.kernel.stable
Date: 2014-10-05 17:24:21 GMT

Similar to the stop_machine deadlock scenario on !PREEMPT kernels
addressed in b22ce2785d97 "workqueue: cond_resched() after processing
each work item", kworker threads requeueing back-to-back with zero jiffy
delay can stall RCU. The cond_resched call introduced in that fix will
yield only iff there are other higher priority tasks to run, so force a
quiescent RCU state between work items.

Signed-off-by: Joe Lawrence <joe.lawrence <at> stratus.com>
Link: https://lkml.kernel.org/r/20140926105227.01325697 <at> jlaw-desktop.mno.stratus.com
Link: https://lkml.kernel.org/r/20140929115445.40221d8e <at> jlaw-desktop.mno.stratus.com
Fixes: b22ce2785d97 ("workqueue: cond_resched() after processing each work item")
Cc: <stable <at> vger.kernel.org>
---
 kernel/workqueue.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 5dbe22a..345bec9 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
 <at>  <at>  -2043,8 +2043,10  <at>  <at>  __acquires(&pool->lock)
 	 * kernels, where a requeueing work item waiting for something to
 	 * happen could deadlock with stop_machine as such work item could
 	 * indefinitely requeue itself while all other CPUs are trapped in
-	 * stop_machine.
+	 * stop_machine. At the same time, report a quiescent RCU state so
+	 * the same condition doesn't freeze RCU.
 	 */
+	rcu_note_context_switch(current);
 	cond_resched();

 	spin_lock_irq(&pool->lock);
-- 
1.7.10.4
