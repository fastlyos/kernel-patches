From c5b88bacb286e3dd51bffb629da18ce6a3324045 Mon Sep 17 00:00:00 2001
From: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date: Wed, 6 Aug 2014 17:34:22 +0800
Subject: btrfs: cancel scrub/replace if the user space process receive
 SIGKILL.

When impatient sysadmin is tired of waiting background running btrfs
scrub/replace and send SIGKILL to btrfs process, unlike
SIGINT/SIGTERM which can be caught by user space program and cancel the
scrub work, user space program will continue running until ioctl exits.

To keep it consistent with the behavior of btrfs-progs, which cancels
the work when SIGINT is received, this patch will make scrub routine to
check SIGKILL pending of current task and cancel the work if SIGKILL is
already pending.

Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 6a82135..695623e 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -2281,6 +2281,29 @@ static int get_raid56_logic_offset(u64 physical, int num,
 	return 1;
 }
 
+/*
+ * check whether the scrub is canceled
+ * if canceled, return -ECANCELED, else return 0
+ *
+ * scrub/replace will be canceled when
+ * 1) cancel is called manually
+ * 2) caller user space process(btrfs-progs) receive SIGKILL
+ * other signals can be caught in btrfs-progs using multi-thread
+ * and cancel the work.
+ * but SIGKILL can't be caught and btrfs-progs already fallen into ioctl
+ * so cancel current scrub to return asap if SIGKILL is received.
+ */
+static inline int is_scrub_canceled(struct btrfs_fs_info *fs_info,
+				    struct scrub_ctx *sctx)
+{
+	int ret = 0;
+
+	if (unlikely(atomic_read(&fs_info->scrub_cancel_req) ||
+		     atomic_read(&sctx->cancel_req) ||
+		     __fatal_signal_pending(current)))
+		ret = -ECANCELED;
+	return ret;
+}
 static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,
 					   struct map_lookup *map,
 					   struct btrfs_device *scrub_dev,
@@ -2424,11 +2447,9 @@ static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,
 		/*
 		 * canceled?
 		 */
-		if (atomic_read(&fs_info->scrub_cancel_req) ||
-		    atomic_read(&sctx->cancel_req)) {
-			ret = -ECANCELED;
+		ret = is_scrub_canceled(fs_info, sctx);
+		if (ret)
 			goto out;
-		}
 		/*
 		 * check to see if we have to pause
 		 */
-- 
cgit v0.10.1

