From: Miao Xie <miaox@cn.fujitsu.com>
Newsgroups: gmane.comp.file-systems.btrfs
Subject: [PATCH v2 06/10] Btrfs: Fix the problem that the dirty flag of dev stats is cleared
Date: Wed, 3 Sep 2014 14:59:50 +0800
Message-ID: <1409727590-21247-1-git-send-email-miaox@cn.fujitsu.com>
Archived-At: <http://permalink.gmane.org/gmane.comp.file-systems.btrfs/38252>

The io error might happen during writing out the device stats, and the
device stats information and dirty flag would be update at that time,
but the current code didn't consider this case, just clear the dirty flag,
it would cause that we forgot to write out the new device stats
information. Fix it.

Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

Changelog v1 -> v2:
Change the variant name and make some cleanup by David's comment
---
 fs/btrfs/volumes.c |  8 ++++++--
 fs/btrfs/volumes.h | 16 ++++++++++++----
 2 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 19188df..4ea73c8 100644 --- a/fs/btrfs/volumes.c +++ b/fs/btrfs/volumes.c
@@ -159,6 +159,7 @@ static struct btrfs_device *__alloc_device(void)
 
 	spin_lock_init(&dev->reada_lock); atomic_set(&dev->reada_in_flight, 0);
+	atomic_set(&dev->dev_stats_dirty, 0);
 	INIT_RADIX_TREE(&dev->reada_zones, GFP_NOFS & ~__GFP_WAIT);
 	INIT_RADIX_TREE(&dev->reada_extents, GFP_NOFS & ~__GFP_WAIT);
 
@@ -6398,16 +6399,19 @@ int btrfs_run_dev_stats(struct btrfs_trans_handle
*trans,
 	struct btrfs_root *dev_root = fs_info->dev_root;
 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices; struct
 	btrfs_device *device;
+	int dirtied;
 	int ret = 0;
 
 	mutex_lock(&fs_devices->device_list_mutex); list_for_each_entry(device,
 	&fs_devices->devices, dev_list) {
-		if (!device->dev_stats_valid || !device->dev_stats_dirty)
+		dirtied = atomic_read(&device->dev_stats_dirty);
+
+		if (!device->dev_stats_valid || !dirtied)
 			continue;
 
 		ret = update_dev_stat_item(trans, dev_root, device);
 		if (!ret)
-			device->dev_stats_dirty = 0;
+			atomic_sub(dirtied, &device->dev_stats_dirty);
 	}
 	mutex_unlock(&fs_devices->device_list_mutex);
 
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h index
6fcc8ea..9a1eff3 100644 --- a/fs/btrfs/volumes.h +++ b/fs/btrfs/volumes.h
@@ -110,7 +110,8 @@ struct btrfs_device {
 	/* disk I/O failure stats. For detailed description refer to
 	 * enum btrfs_dev_stat_values in ioctl.h */
 	int dev_stats_valid;
-	int dev_stats_dirty; /* counters need to be written to disk */
+
+	atomic_t dev_stats_dirty; /* counters need to be written to disk */
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 };
 
@@ -359,11 +360,18 @@ unsigned long btrfs_full_stripe_len(struct
btrfs_root *root,
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 				struct btrfs_root *extent_root, u64 chunk_offset, u64 chunk_size);
+
+static inline void btrfs_dev_dirty_stat(struct btrfs_device *dev)
+{
+	smp_mb__before_atomic_inc();
+	atomic_inc(&dev->dev_stats_dirty);
+}
+
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {
 	atomic_inc(dev->dev_stat_values + index);
-	dev->dev_stats_dirty = 1;
+	btrfs_dev_dirty_stat(dev);
 }
 
 static inline int btrfs_dev_stat_read(struct btrfs_device *dev,
@@ -378,7 +386,7 @@ static inline int btrfs_dev_stat_read_and_reset(struct
btrfs_device *dev,
 	int ret;
 
 	ret = atomic_xchg(dev->dev_stat_values + index, 0);
-	dev->dev_stats_dirty = 1;
+	btrfs_dev_dirty_stat(dev);
 	return ret;
 }
 
@@ -386,7 +394,7 @@ static inline void btrfs_dev_stat_set(struct
btrfs_device *dev,
 				      int index, unsigned long val)
 {
 	atomic_set(dev->dev_stat_values + index, val);
-	dev->dev_stats_dirty = 1;
+	btrfs_dev_dirty_stat(dev);
 }
 
 static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,

-- 
1.9.3
