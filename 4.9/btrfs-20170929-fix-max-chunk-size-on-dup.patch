Subject: [PATCH] btrfs: fix max chunk size on dup
From:   Naohiro Aota <naohiro.aota@wdc.com>
To:     linux-btrfs@vger.kernel.org
Cc:     jbacik@fb.com, clm@fb.com, dsterba@suse.com
Date:   Fri, 29 Sep 2017 16:20:51 +0900

Balancing a fresh METADATA=dup btrfs file system (with size < 50G)
generates a 128MB sized block group. While we set max_stripe_size =
max_chunk_size = 256MB, we get this half sized block group:

$ btrfs ins dump-t -t CHUNK_TREE btrfs.img|grep length
                length 8388608 owner 2 stripe_len 65536 type DATA
                length 33554432 owner 2 stripe_len 65536 type SYSTEM|DUP
                length 134217728 owner 2 stripe_len 65536 type METADATA|DUP

Before commit 86db25785a6e ("Btrfs: fix max chunk size on raid5/6"), we
used "stripe_size * ndevs > max_chunk_size * ncopies" to check the max
chunk size. Since stripe_size = 256MB * dev_stripes (= 2) = 512MB, ndevs
= 1, max_chunk_size = 256MB, and ncopies = 2, we allowed 256MB
METADATA|DUP block group.

But now, we use "stripe_size * data_stripes > max_chunk_size". Since
data_stripes = 1 on DUP, it disallows the block group to have > 128MB.
What missing here is "dev_stripes". Proper logical space used by the block
group is "stripe_size * data_stripes / dev_stripes". Tweak the equations to
use the right value.

Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
---
 fs/btrfs/volumes.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 0e8f16c305df..d1ac3e1fb753 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -4751,10 +4751,11 @@ static int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 	 * is really going to be in terms of logical address space,
 	 * and compare that answer with the max chunk size
 	 */
-	if (stripe_size * data_stripes > max_chunk_size) {
+	if (stripe_size * data_stripes > max_chunk_size * dev_stripes) {
 		u64 mask = (1ULL << 24) - 1;
 
-		stripe_size = div_u64(max_chunk_size, data_stripes);
+		stripe_size = div_u64(max_chunk_size * dev_stripes,
+				      data_stripes);
 
 		/* bump the answer up to a 16MB boundary */
 		stripe_size = (stripe_size + mask) & ~mask;
